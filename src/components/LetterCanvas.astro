<canvas id="letters-canvas" class="letters-canvas"></canvas>
<style>
  .letters-canvas {
    display: block;
    margin: auto;
    width: 100%;
    max-width: 100%;
    height: auto;
    min-height: 100vh; /* Prevent footer flash during loading */
    box-sizing: border-box;
    overflow-x: hidden;
    grid-column: 1 / 16;
    cursor: default;
    /* Ensure transparent background - no white flashes */
    background: transparent !important;
    /* Optimize for crisp rendering */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    /* Disable text selection and touch behaviors */
    user-select: none;
    -webkit-user-select: none;
    touch-action: pan-y; /* Allow vertical scrolling but prevent other touch gestures */
    /* Improve responsiveness */
    will-change: transform;
    /* Mobile Safari specific fixes */
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
  }
  
  @media (pointer: fine) {
    .letters-canvas:hover {
      cursor: default;
    }
  }
  
  @media (pointer: coarse) {
    .letters-canvas {
      cursor: default;
      touch-action: pan-y; /* Consistent touch behavior for mobile */
    }
  }
</style>
<script type="module" is:inline>
  const letters = [
    { dir: '1-B', count: 9 },
    { dir: '2-O', count: 10 },
    { dir: '3-Y', count: 10 },
    { dir: '4-S', count: 10 },
    { dir: '5-G', count: 10 },
    { dir: '6-O', count: 10 },
    { dir: '7-T', count: 10 },
    { dir: '8-O', count: 8 },
    { dir: '9-J', count: 10 },
    { dir: '10-U', count: 10 },
    { dir: '11-P', count: 10 },
    { dir: '12-I', count: 10 },
    { dir: '13-T', count: 10 },
    { dir: '14-E', count: 9 },
    { dir: '15-R', count: 10 }
  ];

  function randomIndex(max) {
    return Math.floor(Math.random() * max);
  }

  // Extracted colors preserved in src/data/extracted-colors.json for future use

  // Initialize canvas immediately to prevent layout shift
  const canvas = document.getElementById('letters-canvas');
  const ctx = canvas.getContext('2d');
  const numLetters = letters.length;

  // Global variables for canvas behavior (declare early)
  let currentVariants = [];
  let aspectRatio = null;
  let anyImageLoaded = false;
  let fixedViewportHeight = window.innerHeight;
  const imageOpacities = new Map();



  // Set up canvas dimensions immediately with correct aspect ratio
  // Use square skeleton rectangles initially, let actual images determine their aspect ratios
  const parent = canvas.parentElement;
  const width = parent.offsetWidth;
  const height = window.innerHeight;
  const initialAspectRatio = 1.0; // Square skeleton rectangles look better than guessing aspect ratios
  
  // Calculate layout with better initial aspect ratio
  const gapRatio = 0.12;
  const totalGap = (letters.length - 1) * gapRatio;
  const letterWidth = width / (letters.length + totalGap);
  const gap = letterWidth * gapRatio;
  const letterHeight = letterWidth * initialAspectRatio;
  const numRows = Math.floor(height / letterHeight);
  
  canvas.width = width;
  canvas.height = height;
  
  // Canvas should stay transparent to show CSS background
  
  // Initialize variants with correct number of rows from the start
  currentVariants = Array.from({ length: numRows }, () =>
    letters.map((_, col) => randomIndex(letters[col].count))
  );
  
  // Draw skeleton immediately to show progressive loading
  // (aspectRatio will be null initially, but draw() now handles this with initialAspectRatio)
  aspectRatio = initialAspectRatio; // Set initial aspect ratio so draw() works immediately
  draw();

  // Track individual image loading and opacity for fade-in effect

  const allImages = letters.map(({ dir, count }) =>
    Array.from({ length: count }, (_, i) => {
      const img = new window.Image();
      img.src = `/letters/${dir}/${i + 1}.webp`;
      
      // Create unique key for this specific image
      const imageKey = `${dir}-${i + 1}`;
      imageOpacities.set(imageKey, 0);
      
      // Individual image load handler
      const handleImageLoad = () => {
        // Update aspect ratio from first loaded image (but don't resize canvas!)
        if (!anyImageLoaded) {
          aspectRatio = img.naturalHeight / img.naturalWidth;
          anyImageLoaded = true;
          
          // Recalculate layout with correct aspect ratio, but don't resize canvas
          const layout = getLayout();
          const { numRows } = layout;
          
          // Only update variants if the number of rows changed significantly
          if (Math.abs(currentVariants.length - numRows) > 1) {
            currentVariants = Array.from({ length: numRows }, () =>
              letters.map((_, col) => randomIndex(letters[col].count))
            );
          }
          
          // Set up interactive behavior now that we have correct aspect ratio
          if (canvasBehaviorSetup) {
            canvasBehaviorSetup();
          }
        }
        
        // Start individual fade-in animation for this image
        animateImageIn(imageKey);
      };
      
      if (img.complete) {
        handleImageLoad();
      } else {
        img.onload = handleImageLoad;
      }
      
      return img;
    })
  );



  function getLayout() {
    const parent = canvas.parentElement;
    const width = parent.offsetWidth;
    const height = fixedViewportHeight; // Use fixed height to prevent scroll interference
    const gapRatio = 0.12;
    const totalGap = (numLetters - 1) * gapRatio;
    const letterWidth = width / (numLetters + totalGap);
    const gap = letterWidth * gapRatio;
    const letterHeight = letterWidth * (aspectRatio || 1.4); // Fallback to 1.4 if not set
    const numRows = Math.floor(height / letterHeight);
    return { width, height, letterWidth, letterHeight, gap, numRows };
  }



  // Global function needed by animateImageIn
  function draw() {
    // Always draw, even before first image loads (use initial aspect ratio)
    const { width, height, letterWidth, letterHeight, gap, numRows } = getLayout();
    
    // NEVER resize canvas after initial setup - always use clearRect to prevent white flash
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw each position: skeleton fading out as image fades in
    for (let row = 0; row < numRows; row++) {
      for (let col = 0; col < numLetters; col++) {
        const x = col * (letterWidth + gap);
        const y = row * letterHeight;
        
        // Get current image variant and its opacity
        let imgOpacity = 0;
        if (currentVariants[row]) {
          const variant = currentVariants[row][col];
          
          // Ensure variant is within bounds for this column
          if (variant >= 0 && variant < letters[col].count) {
            const imageKey = `${letters[col].dir}-${variant + 1}`;
            imgOpacity = imageOpacities.get(imageKey) || 0;
          }
        }
        
        const skeletonOpacity = 1 - imgOpacity;
        
        // Draw skeleton for this position (fades out as image loads)
        if (skeletonOpacity > 0) {
          ctx.globalAlpha = skeletonOpacity;
          ctx.fillStyle = `rgba(255, 255, 255, 0.15)`;
          
          // Add slight randomness to make it more dynamic
          const randomOffset = Math.sin((row + col) * 0.5) * 3;
          ctx.fillRect(x + randomOffset, y + randomOffset, letterWidth - 2, letterHeight - 2);
        }
        
        // Draw image for this position (fades in as it loads)
        if (imgOpacity > 0 && currentVariants[row]) {
          ctx.globalAlpha = imgOpacity;
          const variant = currentVariants[row][col];
          // Double check bounds before accessing image
          if (variant >= 0 && variant < letters[col].count && allImages[col][variant]) {
            const img = allImages[col][variant];
            ctx.drawImage(img, x, y, letterWidth, letterHeight);
          }
        }
      }
    }
    
    ctx.globalAlpha = 1; // Reset alpha
  }

  // Animate individual image fade-in
  function animateImageIn(imageKey) {
    const startTime = performance.now();
    const duration = 350; // 350ms per image
    
    function animate() {
      const elapsed = performance.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Smooth easing (ease-out cubic)
      const eased = 1 - Math.pow(1 - progress, 3);
      imageOpacities.set(imageKey, eased);
      

      
      // Trigger redraw
      draw();
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    }
    
    requestAnimationFrame(animate);
  }

  // Global setup behavior function that will be accessible to image load handler
  let canvasBehaviorSetup = null;
  
  function initializeCanvasBehavior() {
    let cleanup = () => {};
    let timers = [];
    let lastHovered = { row: null, col: null };
    let lastLayout = null;

    function isMobile() {
      return !window.matchMedia('(pointer: fine)').matches || window.innerWidth <= 768;
    }

    function clearTimers() {
      timers.forEach(rowTimers => rowTimers && rowTimers.forEach(id => clearTimeout(id)));
      timers = [];
    }

    function removeDesktopListeners() {
      canvas.removeEventListener('mousemove', throttledMouseMove);
      canvas.removeEventListener('mouseleave', handleMouseLeave);
    }

    function handleMouseMove(e) {
      const { letterWidth, gap, letterHeight, numRows } = getLayout();
      const rect = canvas.getBoundingClientRect();
      
      // Get precise mouse coordinates accounting for canvas scaling and DPI
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      
      let hoveredCol = null;
      let hoveredRow = null;
      
      // More efficient column detection using direct calculation
      const rawCol = Math.floor(x / (letterWidth + gap));
      if (rawCol >= 0 && rawCol < numLetters) {
        const startX = rawCol * (letterWidth + gap);
        const endX = startX + letterWidth;
        if (x >= startX && x < endX) {
          hoveredCol = rawCol;
        }
      }
      
      // More efficient row detection using direct calculation
      const rawRow = Math.floor(y / letterHeight);
      if (rawRow >= 0 && rawRow < numRows) {
        const startY = rawRow * letterHeight;
        const endY = startY + letterHeight;
        if (y >= startY && y < endY) {
          hoveredRow = rawRow;
        }
      }
      
      // Only trigger change if we're over a valid letter and it's different from last hovered
      if (
        hoveredRow !== null &&
        hoveredCol !== null &&
        hoveredRow >= 0 && hoveredRow < numRows &&
        hoveredCol >= 0 && hoveredCol < numLetters &&
        (hoveredRow !== lastHovered.row || hoveredCol !== lastHovered.col)
      ) {
        const oldVariant = currentVariants[hoveredRow][hoveredCol];
        const newVariant = (oldVariant + 1) % letters[hoveredCol].count;
        currentVariants[hoveredRow][hoveredCol] = newVariant;
        
        draw();
      }
      
      lastHovered = { row: hoveredRow, col: hoveredCol };
    }

    // Throttled mouse move handler for better performance
    let mouseThrottleTimer = null;
    function throttledMouseMove(e) {
      if (mouseThrottleTimer) return;
      
      mouseThrottleTimer = requestAnimationFrame(() => {
        handleMouseMove(e);
        mouseThrottleTimer = null;
      });
    }

    function handleMouseLeave() {
      lastHovered = { row: null, col: null };
      // Cancel any pending throttled mouse events
      if (mouseThrottleTimer) {
        cancelAnimationFrame(mouseThrottleTimer);
        mouseThrottleTimer = null;
      }
    }

    function setRandomTimerForLetter(row, col) {
      const minDelay = 1500;
      const maxDelay = 3500;
      const delay = Math.random() * (maxDelay - minDelay) + minDelay;
      const id = setTimeout(() => {
                  let newVariant;
          do {
           newVariant = randomIndex(letters[col].count);
         } while (newVariant === currentVariants[row][col] && letters[col].count > 1);
        currentVariants[row][col] = newVariant;
        draw();
        setRandomTimerForLetter(row, col);
      }, delay);
      timers[row][col] = id;
    }

    function initializeVariants(numRows) {
      if (currentVariants.length === 0) {
        // Only initialize if we haven't already
        currentVariants = Array.from({ length: numRows }, () =>
          letters.map((_, col) => randomIndex(letters[col].count))
        );
      } else if (currentVariants.length < numRows) {
        // Add new rows if needed
        const newRows = Array.from({ length: numRows - currentVariants.length }, () =>
          letters.map((_, col) => randomIndex(letters[col].count))
        );
        currentVariants = [...currentVariants, ...newRows];
      } else if (currentVariants.length > numRows) {
        // Remove extra rows if needed
        currentVariants = currentVariants.slice(0, numRows);
      }
    }

    function setupBehavior() {
      // Recompute layout and check if it actually changed
      const layout = getLayout();
      const { numRows } = layout;
      
      // Only reset timers if layout significantly changed (prevents scroll interference)
      const layoutChanged = !lastLayout || 
                           Math.abs(lastLayout.width - layout.width) > 10 ||
                           Math.abs(lastLayout.height - layout.height) > 10 ||
                           lastLayout.numRows !== numRows;
      
      if (layoutChanged) {
        cleanup();
        clearTimers();
        removeDesktopListeners();
        lastHovered = { row: null, col: null };
        
        initializeVariants(numRows);
        timers = Array.from({ length: numRows }, () => Array(numLetters).fill(null));
        lastLayout = layout;
      }

      if (layoutChanged) {
        if (!isMobile()) {
          canvas.addEventListener('mousemove', throttledMouseMove);
          canvas.addEventListener('mouseleave', handleMouseLeave);
          cleanup = () => {
            canvas.removeEventListener('mousemove', throttledMouseMove);
            canvas.removeEventListener('mouseleave', handleMouseLeave);
          };
        } else {
          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numLetters; col++) {
              setRandomTimerForLetter(row, col);
            }
          }
          cleanup = clearTimers;
        }
      }
      
      // Always redraw, even if layout didn't change significantly
      draw();
    }

    // Debounced resize handling to prevent interference during scroll
    let resizeTimeout = null;
    const handleResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        // Only update viewport height for significant changes (not Safari UI changes)
        const currentHeight = window.innerHeight;
        if (Math.abs(currentHeight - fixedViewportHeight) > 100) {
          fixedViewportHeight = currentHeight;
        }
        setupBehavior();
        draw();
      }, 150); // 150ms debounce
    };

    // Use ResizeObserver for robust resize handling
    const resizeObserver = new window.ResizeObserver(handleResize);
    resizeObserver.observe(canvas.parentElement);
    
    // Debounced orientation change handler
    let orientationTimeout = null;
    const handleOrientationChange = () => {
      if (orientationTimeout) clearTimeout(orientationTimeout);
      orientationTimeout = setTimeout(() => {
        // Update viewport height only on actual orientation changes
        fixedViewportHeight = window.innerHeight;
        setupBehavior();
        draw();
      }, 300); // 300ms debounce for orientation
    };
    window.addEventListener('orientationchange', handleOrientationChange);

    // Don't set up behavior until first image loads with correct aspect ratio
    // setupBehavior() will be called from the first image load handler
    
    // Make setupBehavior globally accessible
    canvasBehaviorSetup = setupBehavior;
  }
  
  // Initialize canvas behavior immediately (don't wait for images)
  initializeCanvasBehavior();
</script> 