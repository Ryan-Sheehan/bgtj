<canvas id="letters-canvas" class="letters-canvas"></canvas>
<style>
  .letters-canvas {
    display: block;
    margin: auto;
    width: 100%;
    max-width: 100%;
    height: auto;
    min-height: 100vh; /* Prevent footer flash during loading */
    box-sizing: border-box;
    overflow-x: hidden;
    grid-column: 1 / 16;
    cursor: default;
    /* Optimize for crisp rendering */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    /* Disable text selection and touch behaviors */
    user-select: none;
    -webkit-user-select: none;
    touch-action: pan-y; /* Allow vertical scrolling but prevent other touch gestures */
    /* Improve responsiveness */
    will-change: transform;
  }
  
  @media (pointer: fine) {
    .letters-canvas:hover {
      cursor: default;
    }
  }
  
  @media (pointer: coarse) {
    .letters-canvas {
      cursor: default;
      touch-action: pan-y; /* Consistent touch behavior for mobile */
    }
  }
</style>
<script type="module" is:inline>
  const letters = [
    { dir: '1-B', count: 9 },
    { dir: '2-O', count: 10 },
    { dir: '3-Y', count: 10 },
    { dir: '4-S', count: 10 },
    { dir: '5-G', count: 10 },
    { dir: '6-O', count: 10 },
    { dir: '7-T', count: 10 },
    { dir: '8-O', count: 8 },
    { dir: '9-J', count: 10 },
    { dir: '10-U', count: 10 },
    { dir: '11-P', count: 10 },
    { dir: '12-I', count: 10 },
    { dir: '13-T', count: 10 },
    { dir: '14-E', count: 9 },
    { dir: '15-R', count: 10 }
  ];

  function randomIndex(max) {
    return Math.floor(Math.random() * max);
  }

  // Initialize canvas immediately to prevent layout shift
  const canvas = document.getElementById('letters-canvas');
  const ctx = canvas.getContext('2d');
  const numLetters = letters.length;

  // Set up canvas dimensions immediately 
  const parent = canvas.parentElement;
  const width = parent.offsetWidth;
  const height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  const allImages = letters.map(({ dir, count }) =>
    Array.from({ length: count }, (_, i) => {
      const img = new window.Image();
      img.src = `/letters/${dir}/${i + 1}.webp`;
      return img;
    })
  );

  Promise.all(
    allImages.flat().map(
      img =>
        new Promise(resolve => {
          if (img.complete) resolve();
          else img.onload = resolve;
        })
    )
  ).then(() => {
    const aspectRatio = allImages[0][0].naturalHeight / allImages[0][0].naturalWidth;

    // --- Dynamic behavior switching ---
    let cleanup = () => {};
    let timers = [];
    let lastHovered = { row: null, col: null };

    function isMobile() {
      return !window.matchMedia('(pointer: fine)').matches || window.innerWidth <= 768;
    }

    function clearTimers() {
      timers.forEach(rowTimers => rowTimers && rowTimers.forEach(id => clearTimeout(id)));
      timers = [];
    }

    function removeDesktopListeners() {
      canvas.removeEventListener('mousemove', throttledMouseMove);
      canvas.removeEventListener('mouseleave', handleMouseLeave);
    }

    // We'll store currentVariants as a 2D array: [row][col]
    let currentVariants = [];
    let lastLayout = null;
    
    // Capture initial viewport height to prevent scroll interference on mobile Safari
    let fixedViewportHeight = window.innerHeight;

    function getLayout() {
      const parent = canvas.parentElement;
      const width = parent.offsetWidth;
      const height = fixedViewportHeight; // Use fixed height to prevent scroll interference
      const gapRatio = 0.12;
      const totalGap = (numLetters - 1) * gapRatio;
      const letterWidth = width / (numLetters + totalGap);
      const gap = letterWidth * gapRatio;
      const letterHeight = letterWidth * aspectRatio;
      const numRows = Math.floor(height / letterHeight);
      return { width, height, letterWidth, letterHeight, gap, numRows };
    }

    function draw() {
      const { width, height, letterWidth, letterHeight, gap, numRows } = getLayout();
      canvas.width = width;
      canvas.height = height;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numLetters; col++) {
          const img = allImages[col][currentVariants[row][col]];
          const x = col * (letterWidth + gap);
          const y = row * letterHeight;
          ctx.drawImage(img, x, y, letterWidth, letterHeight);
        }
      }
    }

    function handleMouseMove(e) {
      const { letterWidth, gap, letterHeight, numRows } = getLayout();
      const rect = canvas.getBoundingClientRect();
      
      // Get precise mouse coordinates accounting for canvas scaling and DPI
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      
      let hoveredCol = null;
      let hoveredRow = null;
      
      // More efficient column detection using direct calculation
      const rawCol = Math.floor(x / (letterWidth + gap));
      if (rawCol >= 0 && rawCol < numLetters) {
        const startX = rawCol * (letterWidth + gap);
        const endX = startX + letterWidth;
        if (x >= startX && x < endX) {
          hoveredCol = rawCol;
        }
      }
      
      // More efficient row detection using direct calculation
      const rawRow = Math.floor(y / letterHeight);
      if (rawRow >= 0 && rawRow < numRows) {
        const startY = rawRow * letterHeight;
        const endY = startY + letterHeight;
        if (y >= startY && y < endY) {
          hoveredRow = rawRow;
        }
      }
      
      // Only trigger change if we're over a valid letter and it's different from last hovered
      if (
        hoveredRow !== null &&
        hoveredCol !== null &&
        hoveredRow >= 0 && hoveredRow < numRows &&
        hoveredCol >= 0 && hoveredCol < numLetters &&
        (hoveredRow !== lastHovered.row || hoveredCol !== lastHovered.col)
      ) {
        currentVariants[hoveredRow][hoveredCol] =
          (currentVariants[hoveredRow][hoveredCol] + 1) % allImages[hoveredCol].length;
        draw();
      }
      
      lastHovered = { row: hoveredRow, col: hoveredCol };
    }

    // Throttled mouse move handler for better performance
    let mouseThrottleTimer = null;
    function throttledMouseMove(e) {
      if (mouseThrottleTimer) return;
      
      mouseThrottleTimer = requestAnimationFrame(() => {
        handleMouseMove(e);
        mouseThrottleTimer = null;
      });
    }

    function handleMouseLeave() {
      lastHovered = { row: null, col: null };
      // Cancel any pending throttled mouse events
      if (mouseThrottleTimer) {
        cancelAnimationFrame(mouseThrottleTimer);
        mouseThrottleTimer = null;
      }
    }

    function setRandomTimerForLetter(row, col) {
      const minDelay = 1500;
      const maxDelay = 3500;
      const delay = Math.random() * (maxDelay - minDelay) + minDelay;
      const id = setTimeout(() => {
        let newVariant;
        do {
          newVariant = randomIndex(allImages[col].length);
        } while (newVariant === currentVariants[row][col] && allImages[col].length > 1);
        currentVariants[row][col] = newVariant;
        draw();
        setRandomTimerForLetter(row, col);
      }, delay);
      timers[row][col] = id;
    }

    function initializeVariants(numRows) {
      if (currentVariants.length === 0) {
        // Only initialize if we haven't already
        currentVariants = Array.from({ length: numRows }, () =>
          letters.map((_, col) => randomIndex(allImages[col].length))
        );
      } else if (currentVariants.length < numRows) {
        // Add new rows if needed
        const newRows = Array.from({ length: numRows - currentVariants.length }, () =>
          letters.map((_, col) => randomIndex(allImages[col].length))
        );
        currentVariants = [...currentVariants, ...newRows];
      } else if (currentVariants.length > numRows) {
        // Remove extra rows if needed
        currentVariants = currentVariants.slice(0, numRows);
      }
    }

    function setupBehavior() {
      // Recompute layout and check if it actually changed
      const layout = getLayout();
      const { numRows } = layout;
      
      // Only reset timers if layout significantly changed (prevents scroll interference)
      const layoutChanged = !lastLayout || 
                           Math.abs(lastLayout.width - layout.width) > 10 ||
                           Math.abs(lastLayout.height - layout.height) > 10 ||
                           lastLayout.numRows !== numRows;
      
      if (layoutChanged) {
        cleanup();
        clearTimers();
        removeDesktopListeners();
        lastHovered = { row: null, col: null };
        
        initializeVariants(numRows);
        timers = Array.from({ length: numRows }, () => Array(numLetters).fill(null));
        lastLayout = layout;
      }

      if (layoutChanged) {
        if (!isMobile()) {
          canvas.addEventListener('mousemove', throttledMouseMove);
          canvas.addEventListener('mouseleave', handleMouseLeave);
          cleanup = () => {
            canvas.removeEventListener('mousemove', throttledMouseMove);
            canvas.removeEventListener('mouseleave', handleMouseLeave);
          };
        } else {
          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numLetters; col++) {
              setRandomTimerForLetter(row, col);
            }
          }
          cleanup = clearTimers;
        }
      }
      
      // Always redraw, even if layout didn't change significantly
      draw();
    }

    // Debounced resize handling to prevent interference during scroll
    let resizeTimeout = null;
    const handleResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        // Only update viewport height for significant changes (not Safari UI changes)
        const currentHeight = window.innerHeight;
        if (Math.abs(currentHeight - fixedViewportHeight) > 100) {
          fixedViewportHeight = currentHeight;
        }
        setupBehavior();
        draw();
      }, 150); // 150ms debounce
    };

    // Use ResizeObserver for robust resize handling
    const resizeObserver = new window.ResizeObserver(handleResize);
    resizeObserver.observe(canvas.parentElement);
    
    // Debounced orientation change handler
    let orientationTimeout = null;
    const handleOrientationChange = () => {
      if (orientationTimeout) clearTimeout(orientationTimeout);
      orientationTimeout = setTimeout(() => {
        // Update viewport height only on actual orientation changes
        fixedViewportHeight = window.innerHeight;
        setupBehavior();
        draw();
      }, 300); // 300ms debounce for orientation
    };
    window.addEventListener('orientationchange', handleOrientationChange);

    setupBehavior();
    draw();
  });
</script> 