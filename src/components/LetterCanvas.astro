<canvas id="letters-canvas" class="letters-canvas"></canvas>

<!-- Immediate canvas clearing to prevent Mobile Safari white flash -->
<script>
  // Run immediately to prevent white flash on Mobile Safari
  (function() {
    const canvas = document.getElementById('letters-canvas');
    if (canvas) {
      const ctx = canvas.getContext('2d');
      if (ctx) {
        // Clear immediately with fallback dimensions
        ctx.clearRect(0, 0, canvas.width || 1, canvas.height || 1);
        
        // Mobile Safari detection
        const isMobileSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && 
                              /Safari/.test(navigator.userAgent) && 
                              !/Chrome/.test(navigator.userAgent);
        
        if (isMobileSafari) {
          // Additional Mobile Safari specific clearing
          ctx.globalCompositeOperation = 'source-over';
          ctx.fillStyle = 'rgba(0,0,0,0)';
          ctx.fillRect(0, 0, canvas.width || 1, canvas.height || 1);
          ctx.globalCompositeOperation = 'source-over';
        }
      }
    }
  })();
  
  // Also clear on DOMContentLoaded to catch any late rendering
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('letters-canvas');
    if (canvas) {
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width || 1, canvas.height || 1);
      }
    }
  });
</script>

<style>
  .letters-canvas {
    display: block;
    margin: auto;
    width: 100%;
    max-width: 100%;
    height: auto;
    min-height: 100vh; /* Prevent footer flash during loading */
    box-sizing: border-box;
    overflow-x: hidden;
    grid-column: 1 / 16;
    cursor: default;
    /* Match page background to prevent white flash */
    background: var(--color-bg) !important;
    background-color: var(--color-bg) !important;
    /* Optimize for crisp rendering */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    /* Disable text selection and touch behaviors */
    user-select: none;
    -webkit-user-select: none;
    touch-action: pan-y; /* Allow vertical scrolling but prevent other touch gestures */
    /* Improve responsiveness */
    will-change: transform;
    /* Mobile Safari specific fixes */
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    /* Prevent white flash on mobile Safari */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    /* Additional Mobile Safari fixes */
    -webkit-perspective: 1000;
    perspective: 1000;
    /* Force hardware acceleration and prevent white flash */
    -webkit-transform-style: preserve-3d;
    transform-style: preserve-3d;
  }
  
  /* Mobile Safari specific overrides */
  @supports (-webkit-touch-callout: none) {
    .letters-canvas {
      /* Force transparent background on Mobile Safari */
      background: rgba(0, 0, 0, 0) !important;
      background-color: rgba(0, 0, 0, 0) !important;
      /* Additional Mobile Safari optimizations */
      -webkit-appearance: none;
      appearance: none;
    }
  }
  
  /* Additional Mobile Safari specific rules */
  @media screen and (-webkit-min-device-pixel-ratio: 0) {
    .letters-canvas {
      background: transparent !important;
      background-color: transparent !important;
    }
  }
  
  /* iOS Safari specific */
  @supports (-webkit-touch-callout: none) and (not (translate: none)) {
    .letters-canvas {
      background: rgba(0, 0, 0, 0) !important;
      background-color: rgba(0, 0, 0, 0) !important;
    }
  }
  
  @media (pointer: fine) {
    .letters-canvas:hover {
      cursor: default;
    }
  }
  
  @media (pointer: coarse) {
    .letters-canvas {
      cursor: default;
      touch-action: pan-y; /* Consistent touch behavior for mobile */
    }
  }
</style>
<script type="module" is:inline>
  // Immediately clear canvas to prevent white flash on Mobile Safari
  const canvas = document.getElementById('letters-canvas');
  const ctx = canvas?.getContext('2d');
  
  // CRITICAL: Clear canvas immediately before any other operations
  // This prevents Mobile Safari from showing white background
  if (ctx) {
    ctx.clearRect(0, 0, canvas.width || 1, canvas.height || 1);
  }
  
  const letters = [
    { dir: '1-B', count: 9 },
    { dir: '2-O', count: 10 },
    { dir: '3-Y', count: 10 },
    { dir: '4-S', count: 10 },
    { dir: '5-G', count: 10 },
    { dir: '6-O', count: 10 },
    { dir: '7-T', count: 10 },
    { dir: '8-O', count: 8 },
    { dir: '9-J', count: 10 },
    { dir: '10-U', count: 10 },
    { dir: '11-P', count: 10 },
    { dir: '12-I', count: 10 },
    { dir: '13-T', count: 10 },
    { dir: '14-E', count: 9 },
    { dir: '15-R', count: 10 }
  ];

  function randomIndex(max) {
    return Math.floor(Math.random() * max);
  }

  // Check if harmonized mode is enabled via URL parameter
  function shouldUseHarmonizedMode() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('harmonized') === 'true';
  }

  const useHarmonized = shouldUseHarmonizedMode();
  const lettersPath = useHarmonized ? '/letters-harmonized' : '/letters';

  // Extracted colors preserved in src/data/extracted-colors.json for future use

  // Initialize canvas immediately to prevent layout shift
  const numLetters = letters.length;

  // Global variables for canvas behavior (declare early)
  let currentVariants = [];
  let aspectRatio = null;
  let anyImageLoaded = false;
  let fixedViewportHeight = window.innerHeight;
  const imageOpacities = new Map();

  // Mobile Safari detection and viewport handling
  function isMobileSafari() {
    const ua = navigator.userAgent;
    return /iPad|iPhone|iPod/.test(ua) && /Safari/.test(ua) && !/Chrome/.test(ua);
  }

  function getMobileSafariViewportHeight() {
    if (!isMobileSafari()) return window.innerHeight;
    
    // For mobile Safari, use visual viewport height to account for UI elements
    if (window.visualViewport) {
      return window.visualViewport.height;
    }
    
    // Fallback: use innerHeight but account for potential UI changes
    return window.innerHeight;
  }

  // Set up canvas dimensions immediately with correct aspect ratio
  // Use square skeleton rectangles initially, let actual images determine their aspect ratios
  if (canvas && ctx) {
    const parent = canvas.parentElement;
    const width = parent.offsetWidth;
    const height = getMobileSafariViewportHeight();
    const initialAspectRatio = 1.5; // Taller skeleton rectangles
    
    // Calculate layout with better initial aspect ratio
    const gapRatio = 0.12;
    const totalGap = (letters.length - 1) * gapRatio;
    const letterWidth = width / (letters.length + totalGap);
    const gap = letterWidth * gapRatio;
    const letterHeight = letterWidth * initialAspectRatio;
    const numRows = Math.floor(height / letterHeight);
    
    canvas.width = width;
    canvas.height = height;
    
    // CRITICAL: Clear canvas again after setting dimensions to prevent white flash
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Initialize variants with correct number of rows from the start
    currentVariants = Array.from({ length: numRows }, () =>
      letters.map((_, col) => randomIndex(letters[col].count))
    );
    
    // Draw skeleton immediately to show progressive loading
    // (aspectRatio will be null initially, but draw() now handles this with initialAspectRatio)
    aspectRatio = initialAspectRatio; // Set initial aspect ratio so draw() works immediately
    draw();
  }

  // Track individual image loading and opacity for fade-in effect
  const allImages = letters.map(({ dir, count }) =>
    Array.from({ length: count }, (_, i) => {
      const img = new window.Image();
      img.src = `${lettersPath}/${dir}/${i + 1}.webp`;
      
      // Create unique key for this specific image
      const imageKey = `${dir}-${i + 1}`;
      imageOpacities.set(imageKey, 0);
      
      // Individual image load handler
      const handleImageLoad = () => {
        // Don't update aspect ratio - keep layout consistent across refreshes
        if (!anyImageLoaded) {
          anyImageLoaded = true;
          
          // Set up interactive behavior now that images are loading
          if (canvasBehaviorSetup) {
            canvasBehaviorSetup();
          }
          
          // Set initial image to full opacity immediately
          imageOpacities.set(imageKey, 1);
          draw();
        } else {
          // Only animate for subsequent loads/changes
          animateImageIn(imageKey);
        }
      };
      
      if (img.complete) {
        handleImageLoad();
      } else {
        img.onload = handleImageLoad;
      }
      
      return img;
    })
  );

  function getLayout() {
    if (!canvas) return { width: 0, height: 0, letterWidth: 0, letterHeight: 0, gap: 0, numRows: 0 };
    const parent = canvas.parentElement;
    const width = parent.offsetWidth;
    const height = getMobileSafariViewportHeight(); // Use mobile Safari-aware height
    const gapRatio = 0.12;
    const totalGap = (numLetters - 1) * gapRatio;
    const letterWidth = width / (numLetters + totalGap);
    const gap = letterWidth * gapRatio;
    const letterHeight = letterWidth * (aspectRatio || 1.4); // Fallback to 1.4 if not set
    const numRows = Math.floor(height / letterHeight);
    return { width, height, letterWidth, letterHeight, gap, numRows };
  }

  // Global function needed by animateImageIn
  function draw() {
    if (!canvas || !ctx) return;
    
    // Always draw, even before first image loads (use initial aspect ratio)
    const { width, height, letterWidth, letterHeight, gap, numRows } = getLayout();
    
    // NEVER resize canvas after initial setup - always use clearRect to prevent white flash
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw each position: skeleton fading out as image fades in
    for (let row = 0; row < numRows; row++) {
      for (let col = 0; col < numLetters; col++) {
        const x = col * (letterWidth + gap);
        const y = row * letterHeight;
        
        // Get current image variant and its opacity
        let imgOpacity = 0;
        if (currentVariants[row]) {
          const variant = currentVariants[row][col];
          
          // Ensure variant is within bounds for this column
          if (variant >= 0 && variant < letters[col].count) {
            const imageKey = `${letters[col].dir}-${variant + 1}`;
            imgOpacity = imageOpacities.get(imageKey) || 0;
          }
        }
        
        const skeletonOpacity = 1 - imgOpacity;
        
        // Draw skeleton for this position (fades out as image loads)
        if (skeletonOpacity > 0) {
          ctx.globalAlpha = skeletonOpacity;
          ctx.fillStyle = `rgba(255, 255, 255, 0.15)`;
          
          // Add slight randomness to make it more dynamic
          const randomOffset = Math.sin((row + col) * 0.5) * 3;
          ctx.fillRect(x + randomOffset, y + randomOffset, letterWidth - 2, letterHeight - 2);
        }
        
        // Draw image for this position (fades in as it loads)
        if (imgOpacity > 0 && currentVariants[row]) {
          ctx.globalAlpha = imgOpacity;
          const variant = currentVariants[row][col];
          // Double check bounds before accessing image
          if (variant >= 0 && variant < letters[col].count && allImages[col][variant]) {
            const img = allImages[col][variant];
            ctx.drawImage(img, x, y, letterWidth, letterHeight);
          }
        }
      }
    }
    
    ctx.globalAlpha = 1; // Reset alpha
  }

  // Animate individual image fade-in
  function animateImageIn(imageKey) {
    const startTime = performance.now();
    const duration = 350; // 350ms per image
    
    function animate() {
      const elapsed = performance.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Smooth easing (ease-out cubic)
      const eased = 1 - Math.pow(1 - progress, 3);
      imageOpacities.set(imageKey, eased);
      
      // Trigger redraw
      draw();
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    }
    
    requestAnimationFrame(animate);
  }

  // Global setup behavior function that will be accessible to image load handler
  let canvasBehaviorSetup = null;
  
  function initializeCanvasBehavior() {
    let cleanup = () => {};
    let timers = [];
    let lastHovered = { row: null, col: null };
    let lastLayout = null;

    function isMobile() {
      return !window.matchMedia('(pointer: fine)').matches || window.innerWidth <= 768;
    }

    function clearTimers() {
      timers.forEach(rowTimers => rowTimers && rowTimers.forEach(id => clearTimeout(id)));
      timers = [];
    }

    function removeDesktopListeners() {
      if (canvas) {
        canvas.removeEventListener('mousemove', throttledMouseMove);
        canvas.removeEventListener('mouseleave', handleMouseLeave);
      }
    }

    function handleMouseMove(e) {
      if (!canvas) return;
      
      const { letterWidth, gap, letterHeight, numRows } = getLayout();
      const rect = canvas.getBoundingClientRect();
      
      // Get precise mouse coordinates accounting for canvas scaling and DPI
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      
      let hoveredCol = null;
      let hoveredRow = null;
      
      // More efficient column detection using direct calculation
      const rawCol = Math.floor(x / (letterWidth + gap));
      if (rawCol >= 0 && rawCol < numLetters) {
        const startX = rawCol * (letterWidth + gap);
        const endX = startX + letterWidth;
        if (x >= startX && x < endX) {
          hoveredCol = rawCol;
        }
      }
      
      // More efficient row detection using direct calculation
      const rawRow = Math.floor(y / letterHeight);
      if (rawRow >= 0 && rawRow < numRows) {
        const startY = rawRow * letterHeight;
        const endY = startY + letterHeight;
        if (y >= startY && y < endY) {
          hoveredRow = rawRow;
        }
      }
      
      // Only trigger change if we're over a valid letter and it's different from last hovered
      if (
        hoveredRow !== null &&
        hoveredCol !== null &&
        hoveredRow >= 0 && hoveredRow < numRows &&
        hoveredCol >= 0 && hoveredCol < numLetters &&
        (hoveredRow !== lastHovered.row || hoveredCol !== lastHovered.col)
      ) {
        const oldVariant = currentVariants[hoveredRow][hoveredCol];
        const newVariant = (oldVariant + 1) % letters[hoveredCol].count;
        currentVariants[hoveredRow][hoveredCol] = newVariant;
        
        draw();
      }
      
      lastHovered = { row: hoveredRow, col: hoveredCol };
    }

    // Throttled mouse move handler for better performance
    let mouseThrottleTimer = null;
    function throttledMouseMove(e) {
      if (mouseThrottleTimer) return;
      
      mouseThrottleTimer = requestAnimationFrame(() => {
        handleMouseMove(e);
        mouseThrottleTimer = null;
      });
    }

    function handleMouseLeave() {
      lastHovered = { row: null, col: null };
      // Cancel any pending throttled mouse events
      if (mouseThrottleTimer) {
        cancelAnimationFrame(mouseThrottleTimer);
        mouseThrottleTimer = null;
      }
    }

    function setRandomTimerForLetter(row, col) {
      const minDelay = 1500;
      const maxDelay = 3500;
      const delay = Math.random() * (maxDelay - minDelay) + minDelay;
      const id = setTimeout(() => {
                  let newVariant;
          do {
           newVariant = randomIndex(letters[col].count);
         } while (newVariant === currentVariants[row][col] && letters[col].count > 1);
        currentVariants[row][col] = newVariant;
        draw();
        setRandomTimerForLetter(row, col);
      }, delay);
      timers[row][col] = id;
    }

    function initializeVariants(numRows) {
      if (currentVariants.length === 0) {
        // Only initialize if we haven't already
        currentVariants = Array.from({ length: numRows }, () =>
          letters.map((_, col) => randomIndex(letters[col].count))
        );
      } else if (currentVariants.length < numRows) {
        // Add new rows if needed
        const newRows = Array.from({ length: numRows - currentVariants.length }, () =>
          letters.map((_, col) => randomIndex(letters[col].count))
        );
        currentVariants = [...currentVariants, ...newRows];
      } else if (currentVariants.length > numRows) {
        // Remove extra rows if needed
        currentVariants = currentVariants.slice(0, numRows);
      }
    }

    function setupBehavior() {
      if (!canvas) return;
      
      // Recompute layout and check if it actually changed
      const layout = getLayout();
      const { numRows } = layout;
      
      // Only reset timers if layout significantly changed (prevents scroll interference)
      const layoutChanged = !lastLayout || 
                           Math.abs(lastLayout.width - layout.width) > 10 ||
                           Math.abs(lastLayout.height - layout.height) > 10 ||
                           lastLayout.numRows !== numRows;
      
      if (layoutChanged) {
        cleanup();
        clearTimers();
        removeDesktopListeners();
        lastHovered = { row: null, col: null };
        
        initializeVariants(numRows);
        timers = Array.from({ length: numRows }, () => Array(numLetters).fill(null));
        lastLayout = layout;
      }

      if (layoutChanged) {
        if (!isMobile()) {
          canvas.addEventListener('mousemove', throttledMouseMove);
          canvas.addEventListener('mouseleave', handleMouseLeave);
          cleanup = () => {
            if (canvas) {
              canvas.removeEventListener('mousemove', throttledMouseMove);
              canvas.removeEventListener('mouseleave', handleMouseLeave);
            }
          };
        } else {
          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numLetters; col++) {
              setRandomTimerForLetter(row, col);
            }
          }
          cleanup = clearTimers;
        }
      }
      
      // Always redraw, even if layout didn't change significantly
      draw();
    }

    // Debounced resize handling to prevent interference during scroll
    let resizeTimeout = null;
    const handleResize = () => {
      if (!canvas) return;
      
      if (resizeTimeout) clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        // Update canvas dimensions to match new parent width
        const parent = canvas.parentElement;
        const newWidth = parent.offsetWidth;
        if (canvas.width !== newWidth) {
          canvas.width = newWidth;
          
          // Only trigger setupBehavior if width actually changed
          setupBehavior();
          draw();
        }
      }, 150); // 150ms debounce
    };

    // Use ResizeObserver for robust resize handling
    if (canvas && canvas.parentElement) {
      const resizeObserver = new window.ResizeObserver(entries => {
        // Only respond to actual width changes
        const entry = entries[0];
        if (entry && entry.contentRect.width !== canvas.width) {
          handleResize();
        }
      });
      resizeObserver.observe(canvas.parentElement);
    }
    
    // Mobile Safari specific: handle visual viewport changes
    if (window.visualViewport && isMobileSafari()) {
      window.visualViewport.addEventListener('resize', () => {
        if (!canvas) return;
        
        // Ignore resize events that are likely from scrolling (keyboard, toolbar, etc)
        if (resizeTimeout) clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          const parent = canvas.parentElement;
          const newWidth = parent.offsetWidth;
          // Only update if width changed significantly
          if (Math.abs(canvas.width - newWidth) > 10) {
            canvas.width = newWidth;
            setupBehavior();
            draw();
          }
        }, 100); // Faster response for visual viewport changes
      });
    }
    
    // Debounced orientation change handler
    let orientationTimeout = null;
    const handleOrientationChange = () => {
      if (!canvas) return;
      
      if (orientationTimeout) clearTimeout(orientationTimeout);
      orientationTimeout = setTimeout(() => {
        const parent = canvas.parentElement;
        const newWidth = parent.offsetWidth;
        // Only update if width changed significantly
        if (Math.abs(canvas.width - newWidth) > 10) {
          canvas.width = newWidth;
          setupBehavior();
          draw();
        }
      }, 300); // 300ms debounce for orientation
    };
    window.addEventListener('orientationchange', handleOrientationChange);

    // Don't set up behavior until first image loads with correct aspect ratio
    // setupBehavior() will be called from the first image load handler
    
    // Make setupBehavior globally accessible
    canvasBehaviorSetup = setupBehavior;
  }
  
  // Initialize canvas behavior immediately (don't wait for images)
  initializeCanvasBehavior();
</script> 